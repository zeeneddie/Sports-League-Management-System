<!DOCTYPE html>
<html lang="nl">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Liga Dashboard</title>
    <link
      href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css"
      rel="stylesheet"
    />
    <style>
      /* === GLOBAL STYLES === */
      body {
        font-size: 1.4rem; /* Larger base font for HD displays */
        background-color: #d4d4d4 !important; /* Much darker grey background (4 shades darker total) */
        background-image: repeating-linear-gradient(
          45deg,
          transparent,
          transparent 2cm,
          #ffffe0 2cm,
          #ffffe0 calc(2cm + 2px)
        ) !important;
      }

      /* === CAROUSEL CONTAINER === */
      /* Used by all 6 dashboard screens as main container */
      .carousel-item {
        min-height: 100vh;
        padding: 30px 30px 60px 30px; /* Extra bottom padding for countdown footer */
        position: relative;
        background-color: #d4d4d4; /* Much darker grey background (4 shades darker total) */
        background-image: repeating-linear-gradient(
          45deg,
          transparent,
          transparent 2cm,
          #ffffe0 2cm,
          #ffffe0 calc(2cm + 2px)
        );
      }

      /* Columbia logo as background in top left */
      .carousel-item::before {
        content: "";
        position: absolute;
        top: 20px;
        left: 20px;
        width: 100px;
        height: 100px;
        background-image: url("/static/images/team_logos/t_184.png");
        background-size: contain;
        background-repeat: no-repeat;
        background-position: center;
        opacity: 0.4;
        filter: contrast(1.5) saturate(1.8) brightness(1.2);
        z-index: 1;
      }

      /* === SCHERM 1 & 2: MAIN STANDINGS + PERIOD STANDINGS === */
      /* Main table container for league standings */
      .standings-table {
        font-size: 1.3rem;
        margin-top: 1cm;
      }

      /* All table headers and cells padding */
      .standings-table th,
      .standings-table td {
        padding: 12px 8px;
      }

      /* Generic table headers */
      .standings-table th {
        font-size: 2.6rem; /* 2x the normal table font size (was 1.3rem) */
        font-weight: bold;
      }

      /* Position column (#) header in standings table */
      .position-header {
        font-size: 3.9rem; /* 1.5x van 2.6rem = 3.9rem */
      }

      /* Position number cells in standings table */
      .position-cell {
        font-size: 1.95rem; /* 1.5x van 1.3rem = 1.95rem */
        font-weight: bold;
      }

      /* Statistics headers (G, W, G, V) in standings table */
      .stats-header {
        font-size: 3.9rem; /* 1.5x van 2.6rem = 3.9rem */
      }

      /* Statistics data cells in standings table */
      .stats-cell {
        font-size: 1.95rem; /* 1.5x van 1.3rem = 1.95rem */
      }

      /* Points column cells in standings table */
      .points-cell {
        font-size: 1.95rem; /* 1.5x van 1.3rem = 1.95rem */
        font-weight: bold;
      }

      /* Team name column width and alignment */
      .team-name-col {
        min-width: 360px;
        text-align: left;
      }

      /* Team name cells with logo and text */
      .team-name-cell {
        font-size: 2.5rem;
        font-weight: 500;
        text-align: left;
      }

      /* === SCHERM 3 & 4: LAST WEEK RESULTS + NEXT WEEK MATCHES === */
      /* Legacy match result class (not actively used in current screens) */
      .match-result {
        margin-bottom: 15px;
        padding: 10px 0;
        font-size: 1.3rem;
      }

      /* Container for results and upcoming matches screens */
      .results-table {
        max-width: 800px;
        margin: 0 auto;
        font-size: 1.3rem;
      }

      /* Week header for results screen */
      .week-header {
        text-align: center;
        font-size: 2rem;
        font-weight: bold;
        margin-bottom: 20px;
        color: #0066cc;
      }

      /* Individual match rows in results and upcoming matches screens */
      .result-row {
        display: flex;
        align-items: center;
        padding: 8px 0; /* Increased padding for larger text */
        border-bottom: 1px solid #e9ecef;
        font-size: 1.512rem;
        height: 60px; /* Increased height for larger text */
      }

      .result-row:last-child {
        border-bottom: none;
      }

      /* Home team display in results/upcoming matches */
      .result-home {
        flex: 1;
        text-align: left;
        font-size: 2.5rem;
        font-weight: 500;
        color: #495057;
        padding-right: 2px;
        margin-left: -6.5cm;
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
        display: flex;
        align-items: center;
      }

      /* Score display (results) or date/time display (upcoming matches) */
      .result-score {
        flex: 0 0 auto;
        text-align: center;
        font-size: 1.95rem;
        font-weight: bold;
        color: #0066cc;
        min-width: 120px;
        padding: 0 2px;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      /* Away team display in results/upcoming matches */
      .result-away {
        flex: 1;
        text-align: left;
        font-size: 2.5rem;
        font-weight: 500;
        color: #495057;
        padding-left: 1cm;
        margin-right: -5cm;
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
        display: flex;
        align-items: center;
      }

      /* Team logos in results and upcoming matches screens */
      .result-home .team-logo,
      .result-away .team-logo {
        width: 40px;
        height: 40px;
      }

      /* === SCHERM 6: TEAM MATRIX === */
      /* Main container for team vs team results matrix */
      .team-matrix {
        font-size: 1.02rem;
        overflow-x: auto;
        max-width: 100%;
        margin-top: 1cm;
      }

      /* Matrix table layout */
      .team-matrix table {
        table-layout: fixed;
        width: 100%;
        max-width: 100vw;
      }

      /* All matrix cells (scores/dates) */
      .team-matrix th,
      .team-matrix td {
        width: 60px;
        height: 40px;
        padding: 2px;
        text-align: center;
        border: 1px solid #ddd;
       a font-size: 1.512rem;
        vertical-align: middle;
        word-wrap: break-word;
        overflow: hidden;
      }

      /* First column (team names) in matrix */
      .team-matrix th:first-child {
        width: 80px;
        text-align: left;
        font-size: 1.3rem;
        font-weight: normal;
      }

      /* Header cells containing team logos */
      .matrix-header-cell {
        height: 40px;
        vertical-align: middle;
        padding: 4px;
        text-align: center;
        width: 60px;
      }

      /* Team logos in matrix header */
      .matrix-header-cell .team-logo {
        width: 36px;
        height: 36px;
        object-fit: contain;
        display: block;
        margin: 0 auto;
      }

      /* Empty top-left cell in matrix - remove left and top borders */
      .matrix-empty-corner {
        border-left: none !important;
        border-top: none !important;
      }

      /* Team name cells in matrix rows */
      .matrix-row-header {
        text-align: left;
        font-size: 2.457rem;
        max-width: 80px;
        width: 80px;
        overflow: visible;
        white-space: normal;
        word-wrap: break-word;
        line-height: 1.2;
        padding: 2px;
        vertical-align: middle;
      }

      /* === GENERAL UI ELEMENTS === */
      /* Last updated timestamp on each screen */
      .last-updated {
        font-size: 1rem;
        color: #666;
        position: absolute;
        bottom: 15px;
        right: 20px;
      }

      /* Footer bar at bottom of screen */
      .screen-footer {
        position: fixed;
        bottom: 0;
        left: 0;
        right: 0;
        width: 100%;
        background-color: rgba(255, 255, 255, 0.9);
        padding: 10px 20px;
        border-top: 2px solid #0066cc;
        z-index: 1000;
        display: flex;
        justify-content: space-between;
        align-items: center;
      }

      /* Screen number indicator on the left */
      .screen-number {
        font-size: 1.2rem;
        color: #0066cc;
        font-weight: bold;
      }

      /* Countdown timer on the right */
      .countdown-timer {
        font-size: 1.2rem;
        color: #0066cc;
        font-weight: bold;
        display: block !important; /* Ensure countdown is always displayed */
      }

      /* === SCHERM 5: COLUMBIA TEAM MATCHES (THUIS/UIT) === */
      /* Main container for Columbia matches - splits home/away in 2 columns */
      .featured-matches-container {
        display: flex;
        gap: 30px;
      }

      /* Individual columns (Thuis/Uit) */
      .featured-column {
        flex: 1;
      }

      /* Make THUIS and UIT headers 1.5x larger */
      .featured-column h4 {
        font-size: calc(1.5 * 1.5rem); /* 1.5x the default h4 size */
      }

      /* Individual match container - FIXED HEIGHT FOR CONSISTENCY */
      .featured-match {
        border: none;
        margin-bottom: 0;
        padding: 8px 14px; /* Increased padding for better vertical spacing */
        border-bottom: 1px solid #e9ecef;
        font-size: 1.512rem;
        display: flex;
        justify-content: space-between;
        align-items: center;
        height: 50px; /* FIXED HEIGHT instead of min-height for consistency */
        width: 100%;
        line-height: 1.2; /* Added consistent line-height */
      }

      .featured-match:last-child {
        border-bottom: none;
      }

      /* Legacy classes - kept for backwards compatibility */
      .featured-match .teams {
        flex: 1;
      }

      .featured-match .date {
        font-weight: 500;
        color: #0066cc;
        white-space: nowrap;
        margin-left: 26px;
        font-size: 1.93rem;
        min-width: 175px;
        text-align: right;
        line-height: 1.2; /* Added consistent line-height */
      }

      .featured-match .score {
        font-weight: 500;
        color: #006600;
        margin-left: 26px;
        font-size: 1.93rem;
        min-width: 175px;
        text-align: right;
        line-height: 1.2; /* Added consistent line-height */
      }

      /* Match layout container within featured-match */
      .match-line {
        display: flex;
        justify-content: space-between;
        align-items: center;
        width: 100%;
        height: 100%; /* Full height of parent container */
      }

      /* Opponent team name in Columbia matches */
      .opponent-name {
        text-align: left;
        flex: 1;
        font-size: 1.93rem;
        font-weight: 500;
        line-height: 1.2; /* Added consistent line-height */
      }

      /* Score and date classes used in Columbia matches - FIXED STYLING */
      .match-result,
      .match-date {
        text-align: right;
        font-weight: 500;
        white-space: nowrap;
        font-size: 1.93rem;
        min-width: 175px;
        line-height: 1.2; /* Added consistent line-height for better alignment */
        height: 100%; /* Full height of parent */
        display: flex;
        align-items: center; /* Vertical centering */
        justify-content: flex-end; /* Right alignment */
      }

      /* Score display for played Columbia matches */
      .match-result {
        color: #006600;
      }

      /* Date display for upcoming Columbia matches */
      .match-date {
        color: #0066cc;
      }

      /* === TEAM HIGHLIGHTING ACROSS SCREENS === */
      /* Highlights Columbia team name in text */
      .featured-team {
        font-weight: bold;
      }

      /* Highlights Columbia team row in standings tables */
      .featured-row {
        font-weight: bold;
      }

      .featured-row td {
        font-weight: bold;
      }

      /* === TEAM LOGOS ACROSS ALL SCREENS === */
      /* Default team logo size */
      .team-logo {
        width: 20px;
        height: 20px;
        border-radius: 2px;
        vertical-align: middle;
        margin-right: 0px;
      }

      /* Larger team logos in standings tables */
      .standings-table .team-logo {
        width: 48px;
        height: 48px;
      }

      /* === LEGACY CLASSES === */
      /* Legacy date styling - may be used in JavaScript */
      .match-date {
        font-weight: bold;
        color: #0066cc;
      }

      /* Legacy score styling - may be used in JavaScript */
      .match-score {
        font-weight: bold;
        color: #006600;
      }

      /* Week section container - used for weekly results grouping */
      .week-section {
        margin-bottom: 40px;
      }

      .week-section h4 {
        font-size: 1.8rem;
        margin-bottom: 20px;
      }

      /* === FORM INDICATORS (LAATSTE 5 WEDSTRIJDEN) - USED IN STANDINGS === */
      /* Container for form dots in standings table */
      .form-indicators {
        display: flex;
        gap: 4px;
        justify-content: center;
        align-items: center;
      }

      /* Individual form dots (win/draw/loss/no-match) */
      .form-dot {
        width: 16px;
        height: 16px;
        border-radius: 50%;
        display: inline-block;
        border: 2px solid #ddd;
        margin: 0 1px;
      }

      /* Win form dot - green */
      .form-dot.win {
        background-color: #28a745;
        border-color: #1e7e34;
      }

      /* Draw form dot - blue */
      .form-dot.draw {
        background-color: #007bff;
        border-color: #0056b3;
      }

      /* Loss form dot - red */
      .form-dot.loss {
        background-color: #dc3545;
        border-color: #bd2130;
      }

      /* No match form dot - gray */
      .form-dot.no-match {
        background-color: #6c757d;
        border-color: #545b62;
      }

      /* Form column header in standings table */
      .form-header {
        text-align: center;
        min-width: 80px;
      }

      /* Form column cell in standings table */
      .form-cell {
        text-align: center;
        padding: 8px 4px !important;
        min-width: 80px;
        vertical-align: middle;
      }

      /* Form indicators legend (currently not displayed) */
      .form-legend {
        font-size: 0.8rem;
        color: #666;
        text-align: center;
        margin-top: 10px;
      }

      .form-legend .legend-item {
        display: inline-block;
        margin: 0 8px;
      }

      .form-legend .legend-dot {
        width: 12px;
        height: 12px;
        border-radius: 50%;
        display: inline-block;
        margin-right: 4px;
        vertical-align: middle;
        border: 1px solid #ddd;
      }

      /* === TYPOGRAPHY ACROSS ALL SCREENS === */
      /* Standard screen titles */
      h2 {
        font-size: 2.5rem;
        margin-bottom: 30px;
      }

      /* Large header for main standings screen */
      h2.competitiestand-header {
        font-size: 4.8rem;
        margin-bottom: 35px;
      }

      /* Sub-section headers */
      h3 {
        font-size: 2rem;
        margin-bottom: 25px;
      }

      /* Column headers (Thuis/Uit in Columbia matches) */
      h4 {
        font-size: 1.6rem;
        margin-bottom: 20px;
      }

      /* === ANIMATED INTRO SCREEN === */
      /* Intro screen with Columbia competition announcement */
      .intro-screen {
        background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
        position: relative;
        overflow: hidden;
        min-height: 100vh;
      }

      /* Football field background animation */
      .football-field {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: linear-gradient(
            90deg,
            transparent 48%,
            rgba(255, 255, 255, 0.1) 50%,
            transparent 52%
          ),
          linear-gradient(
            0deg,
            transparent 48%,
            rgba(255, 255, 255, 0.1) 50%,
            transparent 52%
          );
        background-size: 100px 100px;
        animation: fieldMove 20s linear infinite;
        opacity: 0.3;
      }

      @keyframes fieldMove {
        0% {
          transform: translate(0, 0);
        }
        100% {
          transform: translate(-100px, -100px);
        }
      }

      /* Bouncing football particles */
      .football-particle {
        position: absolute;
        width: 24px;
        height: 24px;
        border-radius: 50%;
        opacity: 0.8;
        background: linear-gradient(
          135deg,
          #ffffff 0%,
          #f0f0f0 50%,
          #ffffff 100%
        );
        border: 2px solid #333;
        /* Football pattern using CSS */
        background-image: radial-gradient(
            circle at 30% 30%,
            #333 2px,
            transparent 2px
          ),
          radial-gradient(circle at 70% 30%, #333 2px, transparent 2px),
          radial-gradient(circle at 50% 70%, #333 2px, transparent 2px);
        background-size: 8px 8px;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
      }

      .football-particle:nth-child(1) {
        left: 15%;
        animation: bounceFootball1 4s infinite ease-in-out;
        animation-delay: 0s;
      }
      .football-particle:nth-child(2) {
        left: 35%;
        animation: bounceFootball2 3.5s infinite ease-in-out;
        animation-delay: 1s;
      }
      .football-particle:nth-child(3) {
        left: 65%;
        animation: bounceFootball3 4.2s infinite ease-in-out;
        animation-delay: 2s;
      }
      .football-particle:nth-child(4) {
        left: 85%;
        animation: bounceFootball4 3.8s infinite ease-in-out;
        animation-delay: 0.5s;
      }

      @keyframes bounceFootball1 {
        0%,
        100% {
          transform: translateY(calc(100vh - 50px)) rotate(0deg);
          opacity: 0.8;
        }
        25% {
          transform: translateY(calc(100vh - 200px)) rotate(90deg);
          opacity: 1;
        }
        50% {
          transform: translateY(calc(100vh - 300px)) rotate(180deg);
          opacity: 1;
        }
        75% {
          transform: translateY(calc(100vh - 150px)) rotate(270deg);
          opacity: 1;
        }
      }

      @keyframes bounceFootball2 {
        0%,
        100% {
          transform: translateY(calc(100vh - 50px)) rotate(0deg);
          opacity: 0.7;
        }
        30% {
          transform: translateY(calc(100vh - 250px)) rotate(120deg);
          opacity: 1;
        }
        60% {
          transform: translateY(calc(100vh - 180px)) rotate(240deg);
          opacity: 1;
        }
      }

      @keyframes bounceFootball3 {
        0%,
        100% {
          transform: translateY(calc(100vh - 50px)) rotate(0deg);
          opacity: 0.8;
        }
        20% {
          transform: translateY(calc(100vh - 350px)) rotate(72deg);
          opacity: 1;
        }
        40% {
          transform: translateY(calc(100vh - 100px)) rotate(144deg);
          opacity: 1;
        }
        60% {
          transform: translateY(calc(100vh - 280px)) rotate(216deg);
          opacity: 1;
        }
        80% {
          transform: translateY(calc(100vh - 120px)) rotate(288deg);
          opacity: 1;
        }
      }

      @keyframes bounceFootball4 {
        0%,
        100% {
          transform: translateY(calc(100vh - 50px)) rotate(0deg);
          opacity: 0.6;
        }
        35% {
          transform: translateY(calc(100vh - 220px)) rotate(135deg);
          opacity: 1;
        }
        70% {
          transform: translateY(calc(100vh - 160px)) rotate(270deg);
          opacity: 1;
        }
      }

      /* Main intro content */
      .intro-content {
        position: relative;
        z-index: 10;
        text-align: center;
        color: white;
        padding: 5vh 2rem;
      }

      /* Columbia logo large display */
      .columbia-logo-large {
        width: 200px;
        height: 200px;
        margin: 0 auto 2rem;
        border: 4px solid rgba(255, 255, 255, 0.3);
        border-radius: 50%;
        padding: 20px;
        background: rgba(255, 255, 255, 0.1);
        backdrop-filter: blur(10px);
        animation: logoGlow 3s ease-in-out infinite;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .columbia-logo-large img {
        width: 100%;
        height: 100%;
        object-fit: contain;
        filter: drop-shadow(0 0 20px rgba(255, 255, 255, 0.5));
      }

      @keyframes logoGlow {
        0%,
        100% {
          box-shadow: 0 0 30px rgba(255, 255, 255, 0.3);
          transform: scale(1);
        }
        50% {
          box-shadow: 0 0 60px rgba(255, 255, 255, 0.6);
          transform: scale(1.05);
        }
      }

      /* Competition announcement text */
      .competition-title {
        font-size: 3.5rem;
        font-weight: bold;
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        margin-bottom: 1rem;
        animation: titleSlideIn 2s ease-out;
      }

      .competition-subtitle {
        font-size: 2rem;
        margin-bottom: 2rem;
        opacity: 0.9;
        animation: subtitleFadeIn 2s ease-out 0.5s both;
      }

      .competition-details {
        font-size: 1.5rem;
        margin-bottom: 3rem;
        opacity: 0.8;
        animation: detailsFadeIn 2s ease-out 1s both;
      }

      @keyframes titleSlideIn {
        0% {
          transform: translateY(-50px);
          opacity: 0;
        }
        100% {
          transform: translateY(0);
          opacity: 1;
        }
      }

      @keyframes subtitleFadeIn {
        0% {
          transform: translateX(-30px);
          opacity: 0;
        }
        100% {
          transform: translateX(0);
          opacity: 0.9;
        }
      }

      @keyframes detailsFadeIn {
        0% {
          transform: translateY(30px);
          opacity: 0;
        }
        100% {
          transform: translateY(0);
          opacity: 0.8;
        }
      }

      /* Loading progress bar */
      .loading-progress {
        width: 60%;
        max-width: 500px;
        margin: 0 auto;
        height: 6px;
        background: rgba(255, 255, 255, 0.2);
        border-radius: 3px;
        overflow: hidden;
        animation: progressBarFadeIn 2s ease-out 1.5s both;
      }

      .progress-fill {
        height: 100%;
        background: linear-gradient(90deg, #fff, #ffeb3b, #fff);
        border-radius: 3px;
        animation: progressFill 3s ease-in-out 2s both;
      }

      @keyframes progressBarFadeIn {
        0% {
          transform: scaleX(0);
          opacity: 0;
        }
        100% {
          transform: scaleX(1);
          opacity: 1;
        }
      }

      @keyframes progressFill {
        0% {
          width: 0%;
          transform: translateX(-100%);
        }
        50% {
          width: 100%;
          transform: translateX(0%);
        }
        100% {
          width: 100%;
          transform: translateX(0%);
        }
      }

      /* === PAGE TRANSITION ANIMATIONS === */
      /* Slide transition effects for carousel screens */
      .carousel-item {
        /* Transition styles removed - ready for custom transitions */
      }

      /* Override Bootstrap's carousel transitions */
      .carousel-item-next,
      .carousel-item-prev,
      .carousel-item.active {
        /* Transition styles removed - ready for custom transitions */
      }

      .carousel-item-left,
      .carousel-item-right {
        /* Transition styles removed - ready for custom transitions */
      }

      /* === TRANSITION FROM ANIMATION TO STANDINGS === */
      /* Special transition effect for intro to first dashboard screen */
      .intro-screen {
        transition: all 1s ease-in-out;
      }

      .intro-screen.fade-out {
        opacity: 0;
        transform: scale(0.95);
      }

      .standings-screen {
        opacity: 0;
        transform: translateY(50px);
        transition: all 1s ease-in-out;
      }

      .standings-screen.fade-in {
        opacity: 1;
        transform: translateY(0);
      }

      @keyframes matrixContentFadeIn {
        0% {
          opacity: 0;
          transform: translateY(30px) scale(0.95);
        }
        100% {
          opacity: 1;
          transform: translateY(0) scale(1);
        }
      }

      /* === CONTENT ENTRY ANIMATIONS === */
      /* All content starts visible instantly, no animation */
      .carousel-item .standings-table tbody tr,
      .carousel-item .result-row,
      .carousel-item .featured-match {
        opacity: 1;
        transform: translateX(0);
      }

      /* Higher specificity rule for matrix table to override Bootstrap table styles */
      .carousel-item .team-matrix table.table {
        opacity: 1 !important;
        transform: scale(1);
        visibility: visible;
      }

      /* === RESPONSIVE DESIGN === */
      /* Smaller padding on smaller screens */
      @media (max-width: 1920px) {
        .carousel-item {
          padding: 20px 20px 60px 20px; /* Keep bottom padding for countdown footer */
        }

        .carousel-item::before {
          top: 15px;
          left: 15px;
          width: 80px;
          height: 80px;
        }

        .competition-title {
          font-size: 2.5rem;
        }

        .columbia-logo-large {
          width: 150px;
          height: 150px;
        }
      }
    </style>
  </head>
  <body>
    <div class="container-fluid">
      <div
        id="carousel"
        class="carousel"
        data-bs-ride="carousel"
        data-bs-interval="{{ (screen_duration_seconds * 1000) | int }}"
      >
        <div class="carousel-indicators" id="carousel-indicators">
          <!-- Will be populated dynamically -->
        </div>

        <div class="carousel-inner" id="carousel-inner">
          <!-- Animated Intro Screen -->
          <div class="carousel-item active intro-screen">
            <div class="football-field"></div>

            <!-- Floating football particles -->
            <div class="football-particle"></div>
            <div class="football-particle"></div>
            <div class="football-particle"></div>
            <div class="football-particle"></div>

            <div class="d-flex justify-content-center align-items-center h-100">
              <div class="intro-content">
                <!-- Columbia Logo Large -->
                <div class="columbia-logo-large">
                  <img
                    src="/static/images/team_logos/t_184.png"
                    alt="AVV Columbia"
                    onerror="this.style.display='none';"
                  />
                </div>

                <!-- Competition Announcement -->
                <h1 class="competition-title" id="competition-main-title">
                  AVV COLUMBIA
                </h1>
                <h2 class="competition-subtitle">Competitie Dashboard</h2>
                <div class="competition-details">
                  <p>Zaterdag 3N OOST • Seizoen 2025-2026</p>
                  <p id="competition-status">Dashboard wordt geladen...</p>
                </div>

                <!-- Loading Progress -->
                <div class="loading-progress">
                  <div class="progress-fill"></div>
                </div>
              </div>
            </div>
          </div>
        </div>

        <button
          class="carousel-control-prev"
          type="button"
          data-bs-target="#carousel"
          data-bs-slide="prev"
        >
          <span class="carousel-control-prev-icon"></span>
        </button>
        <button
          class="carousel-control-next"
          type="button"
          data-bs-target="#carousel"
          data-bs-slide="next"
        >
          <span class="carousel-control-next-icon"></span>
        </button>
      </div>

      <!-- Footer with screen number and countdown -->
      <div class="screen-footer">
        <div class="screen-number" id="screen-number-display"></div>
        <div class="countdown-timer" id="countdown-display"></div>
      </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <script>
            let slideIndex = 0;
            let totalSlides = 0;

            // Screen duration configuration from server
            const SCREEN_DURATION_SECONDS = {{ screen_duration_seconds }};
            const SCREEN_DURATION_MS = SCREEN_DURATION_SECONDS * 1000;
            console.log('Screen duration configured:', SCREEN_DURATION_SECONDS, 'seconds');

            // Featured team info - will be set dynamically from API
            let featuredTeamName = "";
            let featuredTeamKey = "";

            // Simplified carousel variables
            let countdownInterval = null;
            let currentCountdown = SCREEN_DURATION_SECONDS;
            let carouselInstance = null;
            let isInitialized = false;

            // Function to format date
            function formatDate(dateString) {
              if (!dateString) return "Onbekend";
              const date = new Date(dateString);

              // Nederlandse dag- en maandnamen
              const dagen = ['zon', 'maa', 'din', 'woe', 'don', 'vri', 'zat'];
              const maanden = ['jan', 'feb', 'mrt', 'apr', 'mei', 'jun',
                              'jul', 'aug', 'sep', 'okt', 'nov', 'dec'];

              const dag = dagen[date.getDay()];
              const dagVanMaand = String(date.getDate()).padStart(2, '0');
              const maand = maanden[date.getMonth()];
              const jaar = date.getFullYear();

              return `${dag} ${dagVanMaand} ${maand} ${jaar}`;
            }

            // Function to format datetime
            function formatDateTime(dateString) {
              if (!dateString) return "Onbekend";
              const date = new Date(dateString);
              const day = String(date.getDate()).padStart(2, "0");
              const month = String(date.getMonth() + 1).padStart(2, "0");
              const year = String(date.getFullYear()).slice(-2);
              const hours = String(date.getHours()).padStart(2, "0");
              const minutes = String(date.getMinutes()).padStart(2, "0");
              return `${day}-${month}-${year} ${hours}:${minutes}`;
            }

            // Countdown timer functions
            function startCountdown() {
              console.log('Starting countdown with', SCREEN_DURATION_SECONDS, 'seconds');
              
              // Clear any existing countdown
              if (countdownInterval) {
                clearInterval(countdownInterval);
                countdownInterval = null;
              }
              
              currentCountdown = SCREEN_DURATION_SECONDS;
              updateCountdownDisplay();
              
              countdownInterval = setInterval(() => {
                currentCountdown--;
                updateCountdownDisplay();
                
                if (currentCountdown <= 0) {
                  clearInterval(countdownInterval);
                  countdownInterval = null;
                  
                  if (carouselInstance) {
                    carouselInstance.next();
                  }
                }
              }, 1000);
            }

            function updateCountdownDisplay() {
              const countdownElement = document.getElementById('countdown-display');
              if (countdownElement) {
                countdownElement.textContent = currentCountdown;
              }
            }

            function stopCountdown() {
              if (countdownInterval) {
                clearInterval(countdownInterval);
                countdownInterval = null;
              }
            }

            function validateScreenTiming() {
              // Debug function to validate all screens are working correctly
              console.log('=== SCREEN TIMING VALIDATION ===');
              console.log('Screen duration configured:', SCREEN_DURATION_SECONDS, 'seconds');
              console.log('Carousel interval (ms):', carouselIntervalMs);
              console.log('Current countdown:', currentCountdown);
              console.log('Countdown active:', isCountdownActive);
              console.log('Is transitioning:', isTransitioning);
              console.log('Carousel instance exists:', !!carouselInstance);

              const activeSlide = document.querySelector('.carousel-item.active');
              if (activeSlide) {
                const contentType = detectContentType(activeSlide);
                console.log('Active slide content type:', contentType);

                // Count content elements for each type
                const standingsRows = activeSlide.querySelectorAll('.standings-table tbody tr').length;
                const resultRows = activeSlide.querySelectorAll('.result-row').length;
                const featuredMatches = activeSlide.querySelectorAll('.featured-match').length;
                const matrixTable = activeSlide.querySelector('.team-matrix table') ? 1 : 0;

                console.log('Content elements - Standings:', standingsRows, 'Results:', resultRows, 'Featured:', featuredMatches, 'Matrix:', matrixTable);
              }

              // Check if countdown element is visible
              const countdownElement = document.getElementById('countdown-display');
              if (countdownElement) {
                console.log('Countdown element display style:', countdownElement.style.display);
                console.log('Countdown element text content:', countdownElement.textContent);
              } else {
                console.warn('Countdown element not found in DOM');
              }

              console.log('=== END VALIDATION ===');
            }

            function updateScreenNumber() {
              console.log('updateScreenNumber called');
              const activeSlide = document.querySelector('.carousel-item.active');
              if (activeSlide && totalSlides > 0) {
                const slides = document.querySelectorAll('.carousel-item');
                let currentIndex = 0;
                slides.forEach((slide, index) => {
                  if (slide === activeSlide) {
                    currentIndex = index;
                  }
                });

                const screenNumberElement = document.getElementById('screen-number-display');
                if (screenNumberElement) {
                  const displayText = `${currentIndex + 1}/${totalSlides}`;
                  screenNumberElement.textContent = displayText;
                  console.log('Screen number updated:', displayText);
                } else {
                  console.warn('Screen number element not found');
                }

                console.log('Screen number updated:', currentIndex + 1, 'of', totalSlides);
              } else {
                console.warn('Could not update screen number - no active slide or totalSlides = 0');
              }
            }

            function resetCountdown() {
              updateScreenNumber();
              startCountdown();
            }

            // Team logo mappings - Updated based on icon_set.csv
            const teamLogos = {
              "VV Gorecht": "/static/images/team_logos/t_184.png",
              Columbia: "/static/images/team_logos/t_184.png",
              "AVV Columbia": "/static/images/team_logos/t_184.png",
              AGOVV: "/static/images/team_logos/t_23.png",
              "SV Epe": "/static/images/team_logos/t_23.png",
              "Groen Wit '62": "/static/images/team_logos/t_22.png",
              "SV 't Harde": "/static/images/team_logos/t_22.png",
              "VV Hattem": "/static/images/team_logos/t_48.png",
              "SV Hatto Heim": "/static/images/team_logos/t_48.png",
              "VV Heerde": "/static/images/team_logos/t_184.png",
              OWIOS: "/static/images/team_logos/t_22.png",
              "VV SEH": "/static/images/team_logos/t_43.png",
              "SP Teuge": "/static/images/team_logos/t_22.png",
              "VIOS V": "/static/images/team_logos/t_804.png",
              VVOP: "/static/images/team_logos/t_664.png",
              "Zwart-Wit '63": "/static/images/team_logos/t_136.png",
            };

            // Function to format team name with logo and Columbia highlighting
            function formatTeamName(
              teamName,
              includeLogo = false,
              showNameWithLogo = false
            ) {
              if (!teamName) return "";

              let html = "";

              // If logo requested
              if (includeLogo) {
                const logoPath =
                  teamLogos[teamName] || "/static/images/team_logos/default_team.png";
                html += `<img src="${logoPath}" class="team-logo" alt="${teamName}" title="${teamName}" onerror="this.src='/static/images/team_logos/default_team.png'">`;

                // If we should show name with logo, add the name after logo with 3 spaces
                if (showNameWithLogo) {
                  html += "&nbsp;&nbsp;&nbsp;"; // 3 non-breaking spaces
                  if (
                    teamName.toLowerCase().includes(featuredTeamKey.toLowerCase())
                  ) {
                    html += `<span class="featured-team">${teamName}</span>`;
                  } else {
                    html += teamName;
                  }
                }

                return html;
              }

              // Otherwise show team name with featured team highlighting
              if (
                featuredTeamKey &&
                teamName.toLowerCase().includes(featuredTeamKey.toLowerCase())
              ) {
                return `<span class="featured-team">${teamName}</span>`;
              } else {
                return teamName;
              }
            }

            // Function to get last 5 PLAYED matches for a team
            function getTeamLastFiveMatches(teamName, allMatches) {
              if (!allMatches || !teamName) {
                return [];
              }

              // Filter matches where this team played AND the match was actually played
              const teamMatches = allMatches.filter((match, index) => {
                const homeTeam =
                  match.hometeam || match.home_team || match.home || "";
                const awayTeam =
                  match.awayteam || match.away_team || match.away || "";

                // Check if the team name matches (case-insensitive)
                const homeMatch =
                  homeTeam.toLowerCase().includes(teamName.toLowerCase()) ||
                  teamName.toLowerCase().includes(homeTeam.toLowerCase());
                const awayMatch =
                  awayTeam.toLowerCase().includes(teamName.toLowerCase()) ||
                  teamName.toLowerCase().includes(awayTeam.toLowerCase());

                const isTeamMatch = homeMatch || awayMatch;

                // ✅ CRITICAL FIX: Only include PLAYED matches
                const isPlayedMatch = match.status === "played" || match.status === "Gespeeld";

                const isValidMatch = isTeamMatch && isPlayedMatch;


                return isValidMatch;
              });

              // Sort by date (most recent first) - only include matches with valid dates
              teamMatches.sort((a, b) => {
                const dateA = new Date(a.date || "1900-01-01");
                const dateB = new Date(b.date || "1900-01-01");
                return dateB - dateA;
              });

              // Return last 5 PLAYED matches
              return teamMatches.slice(0, 5);
            }

            // Function to determine match result for a team
            function getMatchResult(match, teamName) {
              const homeTeam = match.hometeam || match.home_team || match.home || "";
              const awayTeam = match.awayteam || match.away_team || match.away || "";

              // Check if match has been played - look for various score fields and status
              const homeScore =
                match.homeGoals || match.homescore || match.home_score;
              const awayScore =
                match.awayGoals || match.awayscore || match.away_score;
              const status = match.status;

              // EXTRA DEBUG for match result

              // Check if this is a played match
              const hasScores =
                homeScore !== undefined &&
                homeScore !== null &&
                awayScore !== undefined &&
                awayScore !== null;
              const isPlayedStatus = status === "played" || status === "Gespeeld";

              if (!hasScores && !isPlayedStatus) {
                return "no-match"; // Not played yet
              }

              // Convert scores to integers, default to 0 if null/undefined
              const homeScoreInt = parseInt(homeScore || 0);
              const awayScoreInt = parseInt(awayScore || 0);

              // Check if the team name matches (case-insensitive and partial match)
              const isHomeTeam =
                homeTeam.toLowerCase().includes(teamName.toLowerCase()) ||
                teamName.toLowerCase().includes(homeTeam.toLowerCase());
              const isAwayTeam =
                awayTeam.toLowerCase().includes(teamName.toLowerCase()) ||
                teamName.toLowerCase().includes(awayTeam.toLowerCase());

              if (isHomeTeam) {
                // Team played at home
                const result = homeScoreInt > awayScoreInt ? "win" :
                               homeScoreInt === awayScoreInt ? "draw" : "loss";
                return result;
              } else if (isAwayTeam) {
                // Team played away
                const result = awayScoreInt > homeScoreInt ? "win" :
                               awayScoreInt === homeScoreInt ? "draw" : "loss";
                return result;
              }

              return "no-match"; // Team not involved in this match
            }

            // Function to generate form indicators HTML
            function generateFormIndicators(teamName, allMatches) {
              const lastFiveMatches = getTeamLastFiveMatches(teamName, allMatches);

              let html = '<div class="form-indicators">';

              // Always show 5 dots
              for (let i = 0; i < 5; i++) {
                if (i < lastFiveMatches.length) {
                  const match = lastFiveMatches[i];
                  const result = getMatchResult(match, teamName);
                  const title = getMatchTooltip(match, teamName, result);
                  html += `<span class="form-dot ${result}" title="${title}"></span>`;
                } else {
                  // No match data available
                  html += `<span class="form-dot no-match" title="Geen wedstrijd"></span>`;
                }
              }

              html += "</div>";
              return html;
            }

            // Function to create tooltip for match
            function getMatchTooltip(match, teamName, result) {
              const homeTeam = match.hometeam || match.home_team || match.home || "";
              const awayTeam = match.awayteam || match.away_team || match.away || "";
              const homeScore =
                match.homeGoals || match.homescore || match.home_score || 0;
              const awayScore =
                match.awayGoals || match.awayscore || match.away_score || 0;
              const date = match.date || "";

              let resultText = "";
              switch (result) {
                case "win":
                  resultText = "Gewonnen";
                  break;
                case "draw":
                  resultText = "Gelijkspel";
                  break;
                case "loss":
                  resultText = "Verloren";
                  break;
                case "no-match":
                  resultText = "Niet gespeeld";
                  break;
              }

              if (result === "no-match") {
                return `${homeTeam} - ${awayTeam} (${date}): ${resultText}`;
              } else {
                return `${homeTeam} ${homeScore}-${awayScore} ${awayTeam} (${date}): ${resultText}`;
              }
            }

            // Function to create carousel indicators
            function createCarouselIndicators(count) {
              const indicatorsContainer = document.getElementById(
                "carousel-indicators"
              );
              if (!indicatorsContainer) return;

              indicatorsContainer.innerHTML = "";

              for (let i = 0; i < count; i++) {
                const button = document.createElement("button");
                button.type = "button";
                button.setAttribute("data-bs-target", "#carousel");
                button.setAttribute("data-bs-slide-to", i.toString());
                if (i === 0) button.classList.add("active");
                button.setAttribute("aria-label", `Slide ${i + 1}`);
                indicatorsContainer.appendChild(button);
              }
            }

            // Function to create slide
            function createSlide(title, content, slideNum, isActive = false) {
              // Check if title contains HTML tags
              const titleHTML = title.includes("<")
                ? title
                : `<h2 class="mb-4">${title}</h2>`;

              return `
                      <div class="carousel-item ${isActive ? "active" : ""}">
                          <div class="d-flex justify-content-center align-items-center h-100" style="position: relative; z-index: 2;">
                              <div class="text-center w-100">
                                  ${titleHTML}
                                  <div id="slide-content-${slideNum}">
                                      ${content}
                                  </div>
                              </div>
                          </div>
                      </div>
                  `;
            }

            // Generate standings table
            function generateStandingsTable(
              standings,
              useColumns = false,
              allMatches = []
            ) {
              if (!standings || standings.length === 0) {
                return "<p>Geen gegevens beschikbaar</p>";
              }

              // If using columns and we have enough teams (>10), split into 2 columns
              if (useColumns && standings.length > 10) {
                const halfPoint = Math.ceil(standings.length / 2);
                const column1 = standings.slice(0, halfPoint);
                const column2 = standings.slice(halfPoint);

                let html = '<div class="row">';

                // Column 1
                html += '<div class="col-md-6">';
                html +=
                  '<table class="table table-striped standings-table"><thead><tr>';
                html +=
                  '<th class="position-header">P</th><th class="team-name-col">Team</th><th class="form-header">V</th><th class="stats-header">G</th><th class="stats-header">W</th><th class="stats-header">G</th><th class="stats-header">V</th><th class="stats-header">P</th>';
                html += "</tr></thead><tbody>";

                column1.forEach((team, index) => {
                  const teamName = formatTeamName(team.team || team.name, true, true);
                  const isFeatured =
                    featuredTeamKey &&
                    (team.team || team.name)
                      .toLowerCase()
                      .includes(featuredTeamKey.toLowerCase());
                  const rowClass = isFeatured ? "featured-row" : "";
                  const formIndicators = generateFormIndicators(
                    team.team || team.name,
                    allMatches
                  );
                  html += `<tr class="${rowClass}">
                              <td class="position-cell">${index + 1}</td>
                              <td class="team-name-cell">${teamName}</td>
                              <td class="form-cell">${formIndicators}</td>
                              <td class="stats-cell">${
                                team.played || team.ges || 0
                              }</td>
                              <td class="stats-cell">${team.wins || team.w || 0}</td>
                              <td class="stats-cell">${team.draws || team.g || 0}</td>
                              <td class="stats-cell">${
                                team.losses || team.v || 0
                              }</td>
                              <td class="points-cell">${
                                team.points || team.pnt || 0
                              }</td>
                          </tr>`;
                });

                html += "</tbody></table></div>";

                // Column 2
                html += '<div class="col-md-6">';
                html +=
                  '<table class="table table-striped standings-table"><thead><tr>';
                html +=
                  '<th class="position-header">P</th><th class="team-name-col">Team</th><th class="form-header">V</th><th class="stats-header">G</th><th class="stats-header">W</th><th class="stats-header">G</th><th class="stats-header">V</th><th class="stats-header">P</th>';
                html += "</tr></thead><tbody>";

                column2.forEach((team, index) => {
                  const teamName = formatTeamName(team.team || team.name, true, true);
                  const isFeatured =
                    featuredTeamKey &&
                    (team.team || team.name)
                      .toLowerCase()
                      .includes(featuredTeamKey.toLowerCase());
                  const rowClass = isFeatured ? "featured-row" : "";
                  const formIndicators = generateFormIndicators(
                    team.team || team.name,
                    allMatches
                  );
                  html += `<tr class="${rowClass}">
                              <td class="position-cell">${halfPoint + index + 1}</td>
                              <td class="team-name-cell">${teamName}</td>
                              <td class="form-cell">${formIndicators}</td>
                              <td class="stats-cell">${
                                team.played || team.ges || 0
                              }</td>
                              <td class="stats-cell">${team.wins || team.w || 0}</td>
                              <td class="stats-cell">${team.draws || team.g || 0}</td>
                              <td class="stats-cell">${
                                team.losses || team.v || 0
                              }</td>
                              <td class="points-cell">${
                                team.points || team.pnt || 0
                              }</td>
                          </tr>`;
                });

                html += "</tbody></table></div>";
                html += "</div>";

                return html;
              }

              // Default single table layout
              let html =
                '<table class="table table-striped standings-table"><thead><tr>';
              html +=
                '<th class="position-header">P</th><th class="team-name-col">Team</th><th class="form-header">V</th><th class="stats-header">G</th><th class="stats-header">W</th><th class="stats-header">G</th><th class="stats-header">V</th><th class="stats-header">P</th>';
              html += "</tr></thead><tbody>";

              standings.forEach((team, index) => {
                const teamName = formatTeamName(team.team || team.name, true, true);
                const isFeatured =
                  featuredTeamKey &&
                  (team.team || team.name)
                    .toLowerCase()
                    .includes(featuredTeamKey.toLowerCase());
                const rowClass = isFeatured ? "featured-row" : "";
                const formIndicators = generateFormIndicators(
                  team.team || team.name,
                  allMatches
                );
                html += `<tr class="${rowClass}">
                          <td class="position-cell">${index + 1}</td>
                          <td class="team-name-cell">${teamName}</td>
                          <td class="form-cell">${formIndicators}</td>
                          <td class="stats-cell">${team.played || team.ges || 0}</td>
                          <td class="stats-cell">${team.wins || team.w || 0}</td>
                          <td class="stats-cell">${team.draws || team.g || 0}</td>
                          <td class="stats-cell">${team.losses || team.v || 0}</td>
                          <td class="points-cell">${team.points || team.pnt || 0}</td>
                      </tr>`;
              });

              html += "</tbody></table>";
              return html;
            }

            // Generate weekly results
            function generateWeeklyResults(matches) {
              if (!matches || matches.length === 0) {
                return "<p>Geen wedstrijden in deze week</p>";
              }

              // Limit to 8 matches maximum
              const limitedMatches = matches.slice(0, 8);

              let html = '<div class="results-table">';

              limitedMatches.forEach((match, index) => {
                const homeTeam = formatTeamName(match.hometeam || match.home_team);
                const awayTeam = formatTeamName(match.awayteam || match.away_team);
                const homeScore = match.homescore || match.home_score || 0;
                const awayScore = match.awayscore || match.away_score || 0;

                html += `<div class="result-row">
                          <div class="result-home">${homeTeam}</div>
                          <div class="result-score">${homeScore} - ${awayScore}</div>
                          <div class="result-away">${awayTeam}</div>
                      </div>`;
              });

              html += "</div>";
              return html;
            }

            // Generate last played week results - shows matches from the week of the most recent played match
            function generateLastPlayedWeekResults(allMatches) {
              if (!allMatches || allMatches.length === 0) {
                return "<p>Geen wedstrijden beschikbaar</p>";
              }

              // Filter only played matches
              const playedMatches = allMatches.filter(match =>
                match.status === "played" || match.status === "Gespeeld"
              );

              if (playedMatches.length === 0) {
                return "<p>Geen gespeelde wedstrijden beschikbaar</p>";
              }

              // Find the most recent played match date
              const mostRecentDate = playedMatches
                .map(match => new Date(match.date))
                .sort((a, b) => b - a)[0];

              if (!mostRecentDate || isNaN(mostRecentDate)) {
                return "<p>Geen geldige wedstrijddatum gevonden</p>";
              }

              // Calculate the week number of the most recent match
              const weekNumber = getWeekNumber(mostRecentDate);
              const year = mostRecentDate.getFullYear();

              // Filter matches from the same week as the most recent match
              const weekMatches = playedMatches.filter(match => {
                const matchDate = new Date(match.date);
                if (isNaN(matchDate)) return false;

                const matchWeekNumber = getWeekNumber(matchDate);
                const matchYear = matchDate.getFullYear();

                return matchWeekNumber === weekNumber && matchYear === year;
              });

              if (weekMatches.length === 0) {
                return "<p>Geen wedstrijden in deze week</p>";
              }

              // Sort matches by date
              weekMatches.sort((a, b) => new Date(a.date) - new Date(b.date));

              // Limit to 8 matches maximum
              const limitedMatches = weekMatches.slice(0, 8);

              let html = `<div class="week-header">Week ${weekNumber} (${year})</div>`;
              html += '<div class="results-table">';

              limitedMatches.forEach((match, index) => {
                const homeTeam = formatTeamName(
                  match.hometeam || match.home_team || match.home || ""
                );
                const awayTeam = formatTeamName(
                  match.awayteam || match.away_team || match.away || ""
                );
                const homeScore = match.homescore || match.home_score || match.homeGoals || 0;
                const awayScore = match.awayscore || match.away_score || match.awayGoals || 0;

                html += `<div class="result-row">
                          <div class="result-home">${homeTeam}</div>
                          <div class="result-score">${homeScore} - ${awayScore}</div>
                          <div class="result-away">${awayTeam}</div>
                      </div>`;
              });

              html += "</div>";
              return html;
            }

            // Helper function to get ISO week number
            function getWeekNumber(date) {
              const d = new Date(date);
              d.setHours(0, 0, 0, 0);
              // Set to nearest Thursday: current date + 4 - current day number
              // Make Sunday's day number 7
              d.setDate(d.getDate() + 4 - (d.getDay() || 7));
              // Get first day of year
              const yearStart = new Date(d.getFullYear(), 0, 1);
              // Calculate full weeks to nearest Thursday
              const weekNo = Math.ceil(((d - yearStart) / 86400000 + 1) / 7);
              return weekNo;
            }


            // Generate upcoming week matches - show matches from week after first upcoming match, grouped by week
            function generateUpcomingMatches(matches) {
              if (!matches || matches.length === 0) {
                return "<p>Geen wedstrijden beschikbaar</p>";
              }

              // Group matches by week_label (provided by backend)
              const matchesByWeek = {};

              matches.forEach((match) => {
                const weekLabel = match.week_label || "Onbekende week";

                if (!matchesByWeek[weekLabel]) {
                  matchesByWeek[weekLabel] = [];
                }
                matchesByWeek[weekLabel].push(match);
              });

              // Sort weeks by week number and year
              const sortedWeekLabels = Object.keys(matchesByWeek).sort((a, b) => {
                // Extract week number and year from "Week X" or "Week X (YYYY)" format
                const matchA = a.match(/Week (\d+)(?: \((\d+)\))?/);
                const matchB = b.match(/Week (\d+)(?: \((\d+)\))?/);

                const weekNumA = parseInt(matchA?.[1] || "0");
                const yearA = parseInt(matchA?.[2] || new Date().getFullYear());

                const weekNumB = parseInt(matchB?.[1] || "0");
                const yearB = parseInt(matchB?.[2] || new Date().getFullYear());

                // First sort by year, then by week number
                if (yearA !== yearB) {
                  return yearA - yearB;
                }
                return weekNumA - weekNumB;
              });

              if (sortedWeekLabels.length === 0) {
                return "<p>Geen toekomstige wedstrijden beschikbaar</p>";
              }

              let html = '<div class="results-table">';

              // Display matches grouped by week with week headers
              sortedWeekLabels.forEach((weekLabel) => {
                const weekMatches = matchesByWeek[weekLabel];

                // Sort matches within the week
                weekMatches.sort((a, b) => {
                  // Check if either match involves featured team
                  const aHasFeatured =
                    featuredTeamKey &&
                    ((a.home || a.hometeam || a.home_team || "")
                      .toLowerCase()
                      .includes(featuredTeamKey.toLowerCase()) ||
                      (a.away || a.awayteam || a.away_team || "")
                        .toLowerCase()
                        .includes(featuredTeamKey.toLowerCase()));
                  const bHasFeatured =
                    featuredTeamKey &&
                    ((b.home || b.hometeam || b.home_team || "")
                      .toLowerCase()
                      .includes(featuredTeamKey.toLowerCase()) ||
                      (b.away || b.awayteam || b.away_team || "")
                        .toLowerCase()
                        .includes(featuredTeamKey.toLowerCase()));

                  // Featured team matches first
                  if (aHasFeatured && !bHasFeatured) return -1;
                  if (!aHasFeatured && bHasFeatured) return 1;

                  // If both have featured team or both don't have featured team, sort by date and time
                  const dateA = new Date(a.date + (a.time ? " " + a.time : ""));
                  const dateB = new Date(b.date + (b.time ? " " + b.time : ""));
                  return dateA - dateB;
                });

                // Add week header
                html += `<div class="week-header">${weekLabel}</div>`;

                // Add matches for this week
                weekMatches.forEach((match) => {
                  const homeTeam = formatTeamName(
                    match.home || match.hometeam || match.home_team,
                    true,
                    true
                  );
                  const awayTeam = formatTeamName(
                    match.away || match.awayteam || match.away_team,
                    true,
                    true
                  );
                  const matchDate = formatDate(match.date);
                  const matchTime = match.time || "";
                  const dateTimeDisplay = matchTime
                    ? `${matchDate} ${matchTime}`
                    : matchDate;

                  html += `<div class="result-row">
                            <div class="result-home">${homeTeam}</div>
                            <div class="result-score">${dateTimeDisplay}</div>
                            <div class="result-away">${awayTeam}</div>
                          </div>`;
                });
              });

              html += "</div>";
              return html;
            }

            // Generate featured team matches in two columns (home/away) with played matches first
            function generateFeaturedTeamMatches(featuredData) {
              if (!featuredData || !featuredData.featured_team_matches) {
                return `<p>Geen ${featuredTeamName} wedstrijden beschikbaar</p>`;
              }

              const playedMatches = featuredData.featured_team_matches.played || [];
              const upcomingMatches =
                featuredData.featured_team_matches.upcoming || [];

              // Combine and separate matches by home/away
              const allMatches = [...playedMatches, ...upcomingMatches];

              const homeMatches = [];
              const awayMatches = [];

              allMatches.forEach((match) => {
                const homeTeam =
                  match.home || match.hometeam || match.home_team || "";
                const awayTeam =
                  match.away || match.awayteam || match.away_team || "";

                if (
                  featuredTeamKey &&
                  homeTeam.toLowerCase().includes(featuredTeamKey.toLowerCase())
                ) {
                  homeMatches.push({ ...match, type: "home" });
                } else if (
                  featuredTeamKey &&
                  awayTeam.toLowerCase().includes(featuredTeamKey.toLowerCase())
                ) {
                  awayMatches.push({ ...match, type: "away" });
                }
              });

              // Debug fallback: show all matches if no upcoming matches found
              if (upcomingMatches.length === 0 && allMatches.length > 0) {
                let debugHtml =
                  '<div class="results-table"><p style="color: orange; font-size: 1rem;">Debug: Alle wedstrijden (geen toekomstige gevonden):</p>';



                  debugHtml += `<div class="result-row">
                            <div class="result-home">${homeTeam}</div>
                            <div class="result-score">${dateTimeDisplay}</div>
                            <div class="result-away">${awayTeam}</div>
                        </div>`;
                });

                debugHtml += "</div>";
                // You can decide how to render this, e.g. inject into DOM or console.log
                // For now, this code just prepares debugHtml as a string
              }

              // Sort matches: played first (by checking if score exists), then by date
              const sortMatches = (matches) => {
                return matches.sort((a, b) => {
                  // Check if match is played (has score)
                  const aPlayed =
                    (a.homeGoals !== undefined && a.homeGoals !== null) ||
                    (a.homescore !== undefined && a.homescore !== null) ||
                    (a.home_score !== undefined && a.home_score !== null);
                  const bPlayed =
                    (b.homeGoals !== undefined && b.homeGoals !== null) ||
                    (b.homescore !== undefined && b.homescore !== null) ||
                    (b.home_score !== undefined && b.home_score !== null);

                  if (aPlayed && !bPlayed) return -1;
                  if (!aPlayed && bPlayed) return 1;

                  // If both played or both unplayed, sort by date
                  const dateA = new Date(a.date || "");
                  const dateB = new Date(b.date || "");
                  return dateA - dateB;
                });
              };

              const sortedHomeMatches = sortMatches(homeMatches);
              const sortedAwayMatches = sortMatches(awayMatches);

              // Generate HTML
              let html = '<div class="featured-matches-container row">';

              // Left column - Home matches
              html += '<div class="featured-column col-md-6">';
              html += '<h4 class="text-center mb-3">Thuis</h4>';

              if (sortedHomeMatches.length === 0) {
                html += '<p class="text-center">Geen thuiswedstrijden</p>';
              } else {
                sortedHomeMatches.forEach((match) => {
                  const opponent =
                    match.away || match.awayteam || match.away_team || "Onbekend";
                  const homeScore =
                    match.homeGoals || match.homescore || match.home_score;
                  const awayScore =
                    match.awayGoals || match.awayscore || match.away_score;
                  const matchDate = match.date ? formatDate(match.date) : "Onbekend";

                  html += '<div class="featured-match">';
                  html += '<div class="match-line">';
                  html += `<div class="opponent-name">${featuredTeamName} - ${formatTeamName(
                    opponent
                  )}</div>`;

                  if (
                    homeScore !== undefined &&
                    homeScore !== null &&
                    awayScore !== undefined &&
                    awayScore !== null
                  ) {
                    // Played match - show score
                    html += `<div class="match-result">${homeScore}-${awayScore}</div>`;
                  } else {
                    // Upcoming match - show date
                    html += `<div class="match-date">${matchDate}</div>`;
                  }

                  html += "</div>";
                  html += "</div>";
                });
              }

              html += "</div>";

              // Right column - Away matches
              html += '<div class="featured-column col-md-6">';
              html += '<h4 class="text-center mb-3">Uit</h4>';

              if (sortedAwayMatches.length === 0) {
                html += '<p class="text-center">Geen uitwedstrijden</p>';
              } else {
                sortedAwayMatches.forEach((match) => {
                  const opponent =
                    match.home || match.hometeam || match.home_team || "Onbekend";
                  const homeScore =
                    match.homeGoals || match.homescore || match.home_score;
                  const awayScore =
                    match.awayGoals || match.awayscore || match.away_score;
                  const matchDate = match.date ? formatDate(match.date) : "Onbekend";

                  html += '<div class="featured-match">';
                  html += '<div class="match-line">';
                  html += `<div class="opponent-name">${formatTeamName(
                    opponent
                  )} - ${featuredTeamName}</div>`;

                  if (
                    homeScore !== undefined &&
                    homeScore !== null &&
                    awayScore !== undefined &&
                    awayScore !== null
                  ) {
                    // Played match - show score
                    html += `<div class="match-result">${homeScore}-${awayScore}</div>`;
                  } else {
                    // Upcoming match - show date
                    html += `<div class="match-date">${matchDate}</div>`;
                  }

                  html += "</div>";
                  html += "</div>";
                });
              }

              html += "</div>";
              html += "</div>";

              return html;
            }


            // Generate team matrix
            function generateTeamMatrix(matrixData) {
              if (!matrixData || !matrixData.teams || !matrixData.matrix) {
                return "<p>Geen team matrix beschikbaar</p>";
              }

              const teams = matrixData.teams;
              const matrix = matrixData.matrix;

              // Function to format date without year or show score as-is with color styling
              function formatMatrixDate(dateStr) {
                if (!dateStr) return { value: "", style: "" };

                // If it's a score (contains dash but no numbers longer than 2 digits)
                if (dateStr.match(/^\d{1,2}-\d{1,2}$/)) {
                  return { value: dateStr, style: "color: #0066cc; font-weight: bold;" }; // Blue for scores
                }

                // If it's a date (YYYY-MM-DD format)
                if (dateStr.match(/^\d{4}-\d{2}-\d{2}$/)) {
                  const date = new Date(dateStr);
                  const formattedDate = date.toLocaleDateString("nl-NL", {
                    day: "2-digit",
                    month: "2-digit",
                  });
                  return { value: formattedDate, style: "color: #28a745; font-weight: bold;" }; // Green for dates
                }

                return { value: dateStr, style: "" };
              }

              let html =
                '<div class="team-matrix"><table class="table table-bordered table-sm">';

              // Header row with only logos
              html += '<thead><tr><th class="matrix-empty-corner"></th>';
              teams.forEach((team) => {
                const logoPath =
                  teamLogos[team] || "/static/images/team_logos/default_team.png";
                const logoContent = `<img src="${logoPath}" class="team-logo" alt="${team}" title="${team}" onerror="this.src='/static/images/team_logos/default_team.png'">`;
                html += `<th title="${team}" class="matrix-header-cell">${logoContent}</th>`;
              });
              html += "</tr></thead><tbody>";

              // Data rows
              teams.forEach((homeTeam) => {
                // Show full team name in row header, no logo
                html += `<tr><th title="${homeTeam}" class="matrix-row-header">${homeTeam}</th>`;
                teams.forEach((awayTeam) => {
                  if (homeTeam === awayTeam) {
                    html += '<td style="background-color: #f8f9fa;">-</td>';
                  } else {
                    const cellValue =
                      matrix[homeTeam] && matrix[homeTeam][awayTeam]
                        ? matrix[homeTeam][awayTeam]
                        : "";
                    const formatResult = cellValue ? formatMatrixDate(cellValue) : { value: "", style: "" };
                    const styleAttr = formatResult.style ? ` style="${formatResult.style}"` : "";
                    html += `<td title="${cellValue}"${styleAttr}>${formatResult.value}</td>`;
                  }
                });
                html += "</tr>";
              });

              html += "</tbody></table></div>";
              return html;
            }

            // Intro screen animation management
            function startIntroAnimation() {
              const competitionStatus = document.getElementById('competition-status');
              const competitionTitle = document.getElementById('competition-main-title');

              // Update status messages during loading
              const statusMessages = [
                'Verbinding maken met competitie server...',
                'Uitslagen ophalen...',
                'Standen berekenen...',
                'Team informatie laden...',
                'Dashboard voorbereiden...',
                'Welkom bij AVV Columbia!'
              ];

              let messageIndex = 0;
              const statusInterval = setInterval(() => {
                if (messageIndex < statusMessages.length) {
                  competitionStatus.textContent = statusMessages[messageIndex];
                  messageIndex++;
                } else {
                  clearInterval(statusInterval);
                }
              }, 800);

              // Dynamic team name update based on featured team
              setTimeout(() => {
                if (featuredTeamName) {
                  competitionTitle.textContent = featuredTeamName.toUpperCase();
                }
              }, 1500);

              return new Promise(resolve => {
                // Resolve after intro animation completes
                setTimeout(() => {
                  console.log('Intro animation completed, resolving promise');
                  resolve();
                }, SCREEN_DURATION_MS);
              });
            }

            // Add smooth transitions to screens
            function addScreenTransitions() {
              const carouselInner = document.getElementById('carousel-inner');
              const slides = carouselInner.querySelectorAll('.carousel-item');

              slides.forEach((slide, index) => {
                // Skip the intro screen
                if (slide.classList.contains('intro-screen')) return;

                // Add specific screen classes based on content type
                const standingsTable = slide.querySelector('.standings-table');
                if (standingsTable) {
                  // Confirm that Standing screen actually has standings rows, not just header
                  const rows = standingsTable.querySelectorAll('tbody tr');
                  if (rows.length > 0) {
                    slide.classList.add('standings-screen');
                  }
                } else if (slide.querySelector('.results-table')) {
                  // Results screen
                  slide.classList.add('results-screen');
                } else if (slide.querySelector('.featured-matches-container')) {
                  // Featured team screen
                  slide.classList.add('featured-screen');
                } else if (slide.querySelector('.team-matrix')) {
                  // Matrix screen
                  slide.classList.add('matrix-screen');
                }
              });
            }

            // Create slide with animation classes
            function createSlideWithAnimations(title, content, slideNum, isActive = false) {
              // Enhanced slide creation with animation support
              const titleHTML = title.includes("<")
                ? title
                : `<h2 class="mb-4">${title}</h2>`;



            // Create slide element without animations
            function createSlideElement(title, content, slideNum, isActive = false) {
              console.log('Creating slide element:', {title, slideNum, isActive});

              // DOM-based slide creation without animations
              const carouselItem = document.createElement('div');
              carouselItem.className = `carousel-item ${isActive ? 'active' : ''}`;
              carouselItem.setAttribute('data-slide-num', slideNum);

              const outerDiv = document.createElement('div');
              outerDiv.className = 'd-flex justify-content-center align-items-center h-100';
              outerDiv.style.position = 'relative';
              outerDiv.style.zIndex = '2';

              const innerDiv = document.createElement('div');
              innerDiv.className = 'text-center w-100';

              // Handle title
              if (title && title.includes('<')) {
                innerDiv.innerHTML = title + content;
              } else if (title) {
                const titleElement = document.createElement('h2');
                titleElement.className = 'mb-4';
                titleElement.textContent = title;
                innerDiv.appendChild(titleElement);
                innerDiv.innerHTML += content;
              } else {
                innerDiv.innerHTML = content;
              }

              // Add last updated timestamp
              const timestamp = document.createElement('div');
              timestamp.className = 'last-updated';
              timestamp.textContent = `Laatst bijgewerkt: ${new Date().toLocaleTimeString('nl-NL')}`;
              innerDiv.appendChild(timestamp);

              outerDiv.appendChild(innerDiv);
              carouselItem.appendChild(outerDiv);

              console.log('Slide element created:', carouselItem);
              return carouselItem;
            }

            // Initialize dashboard
            async function initializeDashboard() {
                console.log('initializeDashboard called');
                return new Promise(async (resolve, reject) => {
                  try {
                    // Start intro animation
                    console.log('Starting intro animation');
                    await startIntroAnimation();

                    // Load all data first
                    console.log('Loading data...');
                    const [
                      standingsResponse,
                      periodsResponse,
                      allMatchesResponse,
                      featuredResponse,
                      weeklyResponse,
                      nextWeekResponse,
                      matrixResponse,
                    ] = await Promise.all([
                      fetch("/api/standings"),
                      fetch("/api/period-standings"),
                      fetch("/api/all-matches"),
                      fetch("/api/featured-team-matches"),
                      fetch("/api/weekly-results"),
                      fetch("/api/next-week-matches"),
                      fetch("/api/team-matrix"),
                    ]);

                    const standingsData = await standingsResponse.json();
                    const periodsData = await periodsResponse.json();
                    const allMatchesData = await allMatchesResponse.json();
                    const featuredData = await featuredResponse.json();
                    const weeklyData = await weeklyResponse.json();
                    const nextWeekData = await nextWeekResponse.json();
                    const matrixData = await matrixResponse.json();

                    console.log('Data loaded successfully');

                    // Set featured team info globally
                    featuredTeamName = featuredData.featured_team_name || "";
                    featuredTeamKey = featuredData.featured_team_key || "";

                    // Build slides array
                    const slides = [];
                    let slideNum = 0;

                    // 1. Main standings
                    console.log('Generating standings table');
                    slides.push({
                      title: "", // No title/header for standings
                      content: generateStandingsTable(
                        standingsData.league_table,
                        true,
                        allMatchesData.matches
                      ),
                      slideNum: slideNum++,
                      lastUpdated: standingsData.last_updated,
                    });

                    // 2. Individual period slides
                    if (
                      periodsData.period_standings &&
                      periodsData.period_standings.length > 0
                    ) {
                      console.log('Generating period standings');
                      periodsData.period_standings.forEach((period) => {
                        slides.push({
                          title: period.name,
                          content: generateStandingsTable(
                            period.standings,
                            true,
                            allMatchesData.matches
                          ),
                          slideNum: slideNum++,
                          lastUpdated: periodsData.last_updated,
                        });
                      });
                    }

                    // 3. Last played week results
                    console.log('Generating last played week results');
                    slides.push({
                      title: "Uitslagen",
                      content: generateLastPlayedWeekResults(allMatchesData.matches || []),
                      slideNum: slideNum++,
                      lastUpdated: allMatchesData.last_updated,
                    });

                    // 4. Next week matches
                    console.log('Generating upcoming matches');
                    let upcomingMatchesContent;
                    try {
                      // If no next week matches, try to use all matches data as fallback
                      if (!nextWeekData.matches || nextWeekData.matches.length === 0) {
                        upcomingMatchesContent = generateUpcomingMatches(
                          allMatchesData.matches || []
                        );
                      } else {
                        upcomingMatchesContent = generateUpcomingMatches(
                          nextWeekData.matches
                        );
                      }
                    } catch (error) {
                      upcomingMatchesContent = "<p>Fout bij laden van wedstrijden</p>";
                    }

                    slides.push({
                      title: "Volgende Wedstrijden",
                      content: upcomingMatchesContent,
                      slideNum: slideNum++,
                      lastUpdated:
                        nextWeekData.last_updated,
                    });

                    // 5. Featured team matches
                    console.log('Generating featured team matches');
                    const featuredContent = generateFeaturedTeamMatches(featuredData);

                    slides.push({
                      title: featuredTeamName.toUpperCase(),
                      content: featuredContent,
                      slideNum: slideNum++,
                      lastUpdated:
                        featuredData.last_updated || new Date().toISOString(),
                    });

                    // 6. Team matrix
                    console.log('Generating team matrix');
                    slides.push({
                      title: "Competitie Zaterdag 3N OOST",
                      content: generateTeamMatrix(matrixData.team_matrix),
                      slideNum: slideNum++,
                      lastUpdated: matrixData.last_updated,
                    });

                    console.log('Total slides prepared:', slides.length);

                    // Create carousel
                    totalSlides = slides.length + 1; // +1 for intro screen
                    createCarouselIndicators(totalSlides);

                    const carouselInner = document.getElementById("carousel-inner");
                    if (!carouselInner) {
                      console.error('Carousel inner container not found');
                      reject(new Error('Carousel inner container not found'));
                      return;
                    }

                    // Keep intro screen and add new slides
                    const introScreen = carouselInner.querySelector('.intro-screen');
                    console.log('Intro screen found:', !!introScreen);

                    // Clear all except intro screen
                    while (carouselInner.children.length > 1) {
                      carouselInner.removeChild(carouselInner.lastChild);
                    }

                    if (!introScreen) {
                      console.warn('Intro screen not found, creating new one');
                      // Create a simple intro screen if it doesn't exist
                      const newIntro = document.createElement('div');
                      newIntro.className = 'carousel-item active intro-screen';
                      newIntro.innerHTML = `
                        <div class="d-flex justify-content-center align-items-center h-100">
                          <div class="text-center">
                            <h1>Welkom</h1>
                            <p>Dashboard wordt geladen...</p>
                          </div>
                        </div>
                      `;
                      carouselInner.appendChild(newIntro);
                    }

                    // Add all dashboard slides without animations using proper DOM methods
                    console.log('Adding', slides.length, 'slides to carousel');
                    slides.forEach((slide, index) => {
                      console.log('Creating slide', index, 'with title:', slide.title);
                      const slideElement = createSlideElement(
                        slide.title,
                        slide.content,
                        slide.slideNum,
                        false // Intro screen stays active initially
                      );
                      carouselInner.appendChild(slideElement);
                    });

                    // Log how many carousel items we now have
                    const allItems = carouselInner.querySelectorAll('.carousel-item');
                    console.log('Total carousel items in DOM:', allItems.length);

                    // Add screen transitions
                    addScreenTransitions();

                    // Initialize screen number display
                    updateScreenNumber();

                    resolve();
                  } catch (error) {
                    console.error('Error in initializeDashboard:', error);
                    reject(error);
                  }
                });
              }

      // Load dashboard when page loads
      document.addEventListener("DOMContentLoaded", function () {
        console.log('DOM Content Loaded');

        // First check if Bootstrap is loaded
        if (typeof bootstrap === "undefined") {
          console.error('Bootstrap is not loaded');
          // Try to load it manually
          const script = document.createElement('script');
          script.src = "https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js";
          script.onload = function() {
            console.log('Bootstrap loaded manually');
            initializeDashboardAfterBootstrap();
          };
          document.head.appendChild(script);
          return;
        }

        console.log('Bootstrap is loaded, initializing dashboard');
        initializeDashboardAfterBootstrap();
      });

      function initializeDashboardAfterBootstrap() {
        console.log('Initializing dashboard after Bootstrap');

        if (isInitialized) {
          console.log('Dashboard already initialized, skipping');
          return;
        }

        initializeDashboard()
          .then(() => {
            console.log('Dashboard initialized successfully');
            initializeCarousel();
            isInitialized = true;
          })
          .catch((error) => {
            console.error('Dashboard initialization error:', error);
          });
      }

      function initializeCarousel() {
        const carouselElement = document.getElementById("carousel");
        if (!carouselElement) {
          console.error('Carousel element not found');
          return;
        }

        const carouselItems = carouselElement.querySelectorAll(".carousel-item");
        if (carouselItems.length < 1) {
          console.error('No carousel items found');
          return;
        }

        try {
          carouselInstance = new bootstrap.Carousel(carouselElement, {
            interval: false,
            ride: false,
            wrap: true,
          });

          totalSlides = carouselItems.length;
          createCarouselIndicators(totalSlides);
          updateScreenNumber();

          carouselElement.addEventListener('slid.bs.carousel', function () {
            resetCountdown();
          });

          startCountdown();
          console.log('Carousel initialized successfully');
        } catch (error) {
          console.error('Carousel setup error:', error);
        }
      }



                  try {
                    carouselInstance = new bootstrap.Carousel(carouselElement, {
                      interval: false, // Disable automatic cycling - we control it with countdown
                      ride: false,
                      wrap: true,
                    });

                    // Setup enhanced carousel transitions
                    // setupCarouselTransitions(); // Removed transition setup

                  } catch (error) {
                    console.error('Error initializing carousel:', error);
                  }

                    // Add keyboard navigation with improved implementation
                    document.addEventListener("keydown", function (event) {
                      if (isTransitioning) {
                        console.log('Transition in progress, ignoring key event');
                        return;
                      }

                      if (event.key === "ArrowLeft" || event.key === "ArrowRight") {
                        event.preventDefault();
                        isTransitioning = true;

                        if (event.key === "ArrowLeft") {
                          console.log('Previous slide requested via keyboard');
                          carouselInstance?.prev();
                        } else {
                          console.log('Next slide requested via keyboard');
                          carouselInstance?.next();
                        }

                        setTimeout(() => {
                          isTransitioning = false;
                        }, 1000);
                      }
                    });

                    // Auto-transition from intro screen to first dashboard screen after intro completes
                    setTimeout(() => {
                      console.log('Intro animation complete, transitioning to first dashboard screen');

                      // Update total slides to include intro + dashboard screens
                      totalSlides = carouselItems.length;
                      createCarouselIndicators(totalSlides);
                      updateScreenNumber();

                      // Ensure countdown is reset before transitioning
                      currentCountdown = SCREEN_DURATION_SECONDS;
                      updateCountdownDisplay();

                      const carouselElement = document.getElementById("carousel");
                      // Add carousel transition event listeners
                      if (carouselElement) {
                        // When slide transition completes
                        carouselElement.addEventListener('slid.bs.carousel', function () {
                          console.log('Carousel slide transition completed');
                          // Reset any transition classes on all slides
                          document.querySelectorAll('.carousel-item').forEach(item => {
                            item.classList.remove('fade-in', 'fade-out');
                          });
                          // Add fade-in effect on active slide
                          const activeSlide = document.querySelector('.carousel-item.active');
                          if (activeSlide) {
                            activeSlide.classList.add('fade-in');
                            console.log('Applied fade-in to active slide');
                          }
                          // Restart countdown for new slide
                          resetCountdown();
                        });

                        // Handle slide transition start
                        carouselElement.addEventListener('slide.bs.carousel', function () {
                          console.log('Carousel slide transition starting');
                          isTransitioning = true;
                          // Clear any existing countdown during transition
                          if (countdownInterval) {
                            clearInterval(countdownInterval);
                            countdownInterval = null;
                            isCountdownActive = false;
                          }
                        });
                      }

                      console.log('Executing transition from intro to first dashboard screen');

                      // Add transition effect from intro to first dashboard screen
                      const introScreen = document.querySelector('.intro-screen');
                      const firstDashboardScreen = document.querySelector('.carousel-item:not(.intro-screen)');
                      if (introScreen && firstDashboardScreen) {
                        // Add fade-out effect to intro screen
                        introScreen.classList.add('fade-out');

                        // Add fade-in effect to first dashboard screen
                        firstDashboardScreen.classList.add('fade-in');

                        // After transition completes, proceed with carousel transition
                        setTimeout(() => {
                          if (carouselInstance) {
                            try {
                              carouselInstance.next();
                              // Start countdown after successful transition
                              startCountdown();
                            } catch (error) {
                              console.error('Error during carousel transition:', error);
                              // Removed fallback to reinitializeCarousel
                            }
                          }
                          // Reset transitioning flag after a delay

      initializeDashboard()
        .then(() => {
          // Check if carousel was already initialized
          if (!carouselInstance) {
            // Start carousel manually after content is loaded
            const carouselElement = document.getElementById("carousel");
            if (!carouselElement) {
              console.error('Carousel element not found');
              return;
            }

            // Check if carousel items exist
            const carouselItems = carouselElement.querySelectorAll(".carousel-item");

            if (carouselItems.length <= 1) {
              console.log('Not enough slides for carousel');
              return;
            }

            try {
              carouselInstance = new bootstrap.Carousel(carouselElement, {
                interval: false, // Disable automatic cycling - we control it with countdown
                ride: false,
                wrap: true,
              });

              // Update total slides count
              totalSlides = carouselItems.length;
              createCarouselIndicators(totalSlides);
              updateScreenNumber();

              // Start the countdown
              startCountdown();
            } catch (error) {
              console.error('Carousel setup error:', error);
            }
          }

          // Refresh data every 30 minutes
          setInterval(() => {
            console.log('Refreshing dashboard data');
            initializeDashboard().then(() => {
              // Restart countdown after data refresh
              if (carouselInstance) {
                console.log('Data refresh complete, resetting countdown');
                resetCountdown();
              } else {
                console.log('No carousel instance, starting carousel');
                // Re-initialize carousel if needed
                const carouselElement = document.getElementById("carousel");
                if (carouselElement) {
                  const carouselItems = carouselElement.querySelectorAll(".carousel-item");
                  if (carouselItems.length > 1) {
                    try {
                      carouselInstance = new bootstrap.Carousel(carouselElement, {
                        interval: false,
                        ride: false,
                        wrap: true,
                      });
                      // Update total slides count
                      totalSlides = carouselItems.length;
                      createCarouselIndicators(totalSlides);
                      updateScreenNumber();
                      resetCountdown();
                    }
                  }
                }
              }
            }).catch((error) => {
              console.error('Error refreshing dashboard data:', error);
              // Even if data refresh fails, restart countdown to keep carousel running
              if (carouselInstance) {
                resetCountdown();
              }
            });
          }, 30 * 60 * 1000);

          // Fallback: Ensure carousel starts even if intro animation fails
          setTimeout(() => {
            // Fallback removed: Initialization disabled to prevent delayed carousel start
            }
          }, SCREEN_DURATION_MS + 2000);

                          setTimeout(() => {
                            isTransitioning = false;
                          }, 1000);
                        }, 800); // Slightly shorter than CSS transition to ensure smoothness
                      } else {
                        // Fallback to direct transition if elements not found
                        if (carouselInstance) {
                          try {
                            carouselInstance.next();
                            startCountdown();
                          } catch (error) {
                            console.error('Error during fallback transition:', error);
                            reinitializeCarousel();
                          }
                        } else {
                          console.warn('No carousel instance available');
                          reinitializeCarousel();
                        }
                        // Reset transitioning flag after a delay
                        setTimeout(() => {
                          isTransitioning = false;
                        }, 1000);
                      } else {
                        // Fallback to direct transition if elements not found
                        if (carouselInstance) {
                          carouselInstance.next();
                        }
                        // Start countdown after the first transition
                        startCountdown();
                      }
                    }, SCREEN_DURATION_MS); // Wait for intro animation to complete

                  } catch (error) {
                    console.error('Carousel setup error:', error);
                  }
                })
                .catch((error) => {
                  // Silent error handling
                });

              // Refresh data every 30 minutes
              setInterval(() => {
                initializeDashboard().then(() => {
                  // Restart countdown after data refresh
                  if (carouselInstance) {
                    resetCountdown();
                  }
                });
              }, 30 * 60 * 1000);

                            // Add a test function to manually trigger carousel
              window.testCarousel = function() {
                console.log('Manual carousel test triggered');
                if (carouselInstance) {
                  console.log('Carousel instance exists, triggering next slide');
                  carouselInstance.next();
                } else {
                  console.log('No carousel instance, trying manual trigger');
                  const carouselElement = document.getElementById("carousel");
                  if (carouselElement) {
                    const nextButton = carouselElement.querySelector('[data-bs-slide="next"]');
                    if (nextButton) {
                      nextButton.click();
                    }
                  }
                }
              };
    </script>
  </body>
</html>
